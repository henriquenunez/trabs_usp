#include <vector>
#include <iostream>
#include <algorithm>
#include <numeric>
#include <utility>

#include <cstdio>
#include <cmath>

typedef enum
{
    UP = 0,
    DOWN = 1,
    LEFT = 2,
    RIGHT = 3
} MOVEMENT;

int moves[4][2] =
{
    -1,  0, //UP
     1,  0, //DOWN
     0, -1, //LEFT
     0,  1  //RIGHT
};

void int_swap(int *a, int *b)
{
    if(*a != *b)
    {
	*a ^= *b;
	*b ^= *a;
	*a ^= *b;
    }
}

class BoardState
{
    int board[3][3];
    int null_x, null_y;
    int misplaced_weight; //Misplaced weight.
    BoardState* parent_state;

    public:
    bool valid;
    BoardState(int init_array[9], BoardState* parent)
    {
	//Init board.
	for (int i = 0 ; i < 9 ; i++)
	{
	    if (init_array == 0) //Set null position.
	    {
		null_x = i/3; null_y = i%3;
	    }
	    board[i/3][i%3] = init_array[i];
	}

	misplaced_weight = 0;
	parent_state = parent;
    }

    ~BoardState() {}

    void print_board()
    {
	for (int i = 0 ; i < 3 ; i++)
	{
	    for (int j = 0 ; j < 3 ; j++)
	    {
		std::cout << board[i][j] << " ";
	    }
	    std::cout << "\n";
	}
    }

    //Checks number of misplaced tiles.
    int check_misplaced()
    {
	for (int i = 0 ; i < 9 ; i++)
	{
	    board[i/3][i%3];
	}
	return -1;
    }

    BoardState generate_state(MOVEMENT mov)
    {
	int temp_board[3][3];
	int temp_array[9];
	int new_i = null_x, new_j = null_y;
	bool valid = true;

	for (int i = 0 ; i < 3 ; i++)
	{
	    for (int j = 0 ; j < 3 ; j++)
	    {
		temp_board[i][j] = this->board[i][j]; //Copying board.
	    }
	}

	switch (mov)
	{
	    case UP:
		new_i += moves[UP][0]; new_j += moves[UP][1];
		break;
	    case RIGHT:
		new_i += moves[RIGHT][0]; new_j += moves[RIGHT][1];
		break;
	    case DOWN:
		new_i += moves[RIGHT][0]; new_j += moves[RIGHT][1];
		break;
	    case LEFT:
		new_i += moves[RIGHT][0]; new_j += moves[RIGHT][1];
		break;
	}

	if(new_i < 0 || new_i > 2 || new_j < 0 || new_j > 2)
	    valid = false;

	if (valid) //Swap positions...
	    int_swap(&temp_board[null_x][null_y], &temp_board[new_i][new_j]);

	//Fill temp array;
	for (int i = 0 ; i < 9 ; i++)
	    temp_array[i] = temp_board[i/3][i%3];

	BoardState ret_board = BoardState(temp_array, this);
	ret_board.valid = valid;

	return ret_board;
    }
};

/*
std::string A_star(BoardState init_state)
{
    std::priority_queue<BoardState> next_states;
    std::unordered_set<std::string> visited;

    BoardState curr_state;

    while(!next_states.empty())
    {
	//Pop state.
	curr_state = next_states.top();
	next_states.pop();

	//Check if curr_state already visited.
	if(visited.count(curr_state.get_string()) == 0)
	{
	    //Check if goal.
	    //Generate descendants.

	}
    }

}
*/
//Todo check solvable.

int main()
{
    int arr[9];
    char temp;
    char temps[2] = {0};

    for (int i = 0 ; i < 9 ; i++)
    {
	std::cin >> temp;
	std::cout << "Got: " << temp << "\n";
	temps[0] = temp;
	if (temp == 'x')
	{
	    std::cout << "XXXXX\n";
	    arr[i] = 0;
	}
	else
	    arr[i] = atoi(temps);
    }

    BoardState a_board = BoardState(arr, NULL);
    a_board.print_board();

    BoardState another_board = a_board.generate_state(UP);
    another_board.print_board();


  //  std::cout << A_star(a_board);
}

